From 1208d461bf2c3b241f993758de5ab9287d638aa5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ra=C3=BAl=20Cumplido?= <raulcumplido@gmail.com>
Date: Tue, 20 Jan 2026 15:32:01 +0100
Subject: [PATCH 3/4] GH-48894: [Python][C++] Use base
 Azure::Core::RequestFailedException instead of final
 Azure::Storage::StorageException and set minimum nodejs on conda env to 16
 for Azurite to work (#48895)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

### Rationale for this change

nodejs 12 is currently being installed on conda. CI jobs are failing and or segfaulting due to azurite failing with old versions.

```
2026-01-13T18:32:39.6961900Z #15 [ 9/11] RUN /arrow/ci/scripts/install_azurite.sh
2026-01-13T18:32:39.9624124Z #15 0.417 Node.js version = v12.4.0
2026-01-13T18:32:42.2087322Z #15 2.663 npm WARN deprecated rimraf@ 3.0.2: Rimraf versions prior to v4 are no longer supported
2026-01-13T18:32:42.3917601Z #15 2.846 npm WARN deprecated uuid@ 3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
2026-01-13T18:32:51.4870197Z #15 11.94 npm WARN deprecated glob@ 7.2.3: Glob versions prior to v9 are no longer supported
2026-01-13T18:32:51.7035681Z #15 12.01 npm WARN deprecated inflight@ 1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.
2026-01-13T18:33:02.1406491Z #15 22.59 /opt/conda/envs/arrow/bin/azurite -> /opt/conda/envs/arrow/lib/node_modules/azurite/dist/src/azurite.js
2026-01-13T18:33:02.3841290Z #15 22.60 /opt/conda/envs/arrow/bin/azurite-queue -> /opt/conda/envs/arrow/lib/node_modules/azurite/dist/src/queue/main.js
2026-01-13T18:33:02.3842792Z #15 22.60 /opt/conda/envs/arrow/bin/azurite-blob -> /opt/conda/envs/arrow/lib/node_modules/azurite/dist/src/blob/main.js
2026-01-13T18:33:02.3844216Z #15 22.60 /opt/conda/envs/arrow/bin/azurite-table -> /opt/conda/envs/arrow/lib/node_modules/azurite/dist/src/table/main.js
2026-01-13T18:33:02.3846002Z #15 22.66 npm WARN applicationinsights@ 2.9.8 requires a peer of applicationinsights-native-metrics@* but none is installed. You must install peer dependencies yourself.
2026-01-13T18:33:02.3847278Z #15 22.66
2026-01-13T18:33:02.3847564Z #15 22.66 + azurite@ 3.35.0
2026-01-13T18:33:02.3848038Z #15 22.66 added 376 packages from 296 contributors in 20.644s
2026-01-13T18:33:02.3848830Z #15 22.69 /opt/conda/envs/arrow/bin/azurite
2026-01-13T18:33:02.8929329Z #15 23.35 /opt/conda/envs/arrow/lib/node_modules/azurite/node_modules/fs-extra/lib/util/async.js:14
2026-01-13T18:33:02.8930231Z #15 23.35         (err) => err ?? new Error('unknown error')
2026-01-13T18:33:02.8930740Z #15 23.35                       ^
```

The job on PyArrow was segfaulting due to an Exception being thrown but not catch. In general we were using `Azure::Storage::StorageException` but `Azure::Core::Http::TransportException` could also be thrown on some cases.
Bot are final but inherit from `Azure::Core::RequestFailedException`.

### What changes are included in this PR?

- Pin minimum nodejs version to 16 so the failure doesn't happen again.
- Update catching `Azure::Storage::StorageException` to `Azure::Core::RequestFailedException` so `Azure::Core::Http::TransportException` is also catch.

### Are these changes tested?

Yes on CI.

### Are there any user-facing changes?

No

* GitHub Issue: #48894

Authored-by: Raúl Cumplido <raulcumplido@gmail.com>
Signed-off-by: Raúl Cumplido <raulcumplido@gmail.com>
---
 ci/conda_env_cpp.txt                |  2 +-
 cpp/src/arrow/filesystem/azurefs.cc | 83 +++++++++++++++--------------
 2 files changed, 43 insertions(+), 42 deletions(-)

diff --git a/ci/conda_env_cpp.txt b/ci/conda_env_cpp.txt
index 18d58f7bb2..fec8488f95 100644
--- a/ci/conda_env_cpp.txt
+++ b/ci/conda_env_cpp.txt
@@ -39,7 +39,7 @@ lz4-c
 make
 meson
 ninja
-nodejs
+nodejs>=16
 orc<2.1.0
 pkg-config
 python
diff --git a/cpp/src/arrow/filesystem/azurefs.cc b/cpp/src/arrow/filesystem/azurefs.cc
index a3a162616e..6580476d38 100644
--- a/cpp/src/arrow/filesystem/azurefs.cc
+++ b/cpp/src/arrow/filesystem/azurefs.cc
@@ -558,7 +558,7 @@ Status CrossContainerMoveNotImplemented(const AzureLocation& src,
       "' requires moving data between containers, which is not implemented.");
 }
 
-bool IsContainerNotFound(const Storage::StorageException& e) {
+bool IsContainerNotFound(const Core::RequestFailedException& e) {
   // In some situations, only the ReasonPhrase is set and the
   // ErrorCode is empty, so we check both.
   if (e.ErrorCode == "ContainerNotFound" ||
@@ -782,7 +782,7 @@ class ObjectInputFile final : public io::RandomAccessFile {
       content_length_ = properties.Value.BlobSize;
       metadata_ = PropertiesToMetadata(properties.Value);
       return Status::OK();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         return PathNotFound(location_);
       }
@@ -864,7 +864,7 @@ class ObjectInputFile final : public io::RandomAccessFile {
       return blob_client_
           ->DownloadTo(reinterpret_cast<uint8_t*>(out), nbytes, download_options)
           .Value.ContentRange.Length.Value();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(
           exception, "DownloadTo from '", blob_client_->GetUrl(), "' at position ",
           position, " for ", nbytes,
@@ -916,7 +916,7 @@ class ObjectInputFile final : public io::RandomAccessFile {
 Status CreateEmptyBlockBlob(const Blobs::BlockBlobClient& block_blob_client) {
   try {
     block_blob_client.UploadFrom(nullptr, 0);
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     return ExceptionToStatus(
         exception, "UploadFrom failed for '", block_blob_client.GetUrl(),
         "'. There is no existing blob at this location or the existing blob must be "
@@ -929,7 +929,7 @@ Result<Blobs::Models::GetBlockListResult> GetBlockList(
     std::shared_ptr<Blobs::BlockBlobClient> block_blob_client) {
   try {
     return block_blob_client->GetBlockList().Value;
-  } catch (Storage::StorageException& exception) {
+  } catch (Core::RequestFailedException& exception) {
     return ExceptionToStatus(
         exception, "GetBlockList failed for '", block_blob_client->GetUrl(),
         "'. Cannot write to a file without first fetching the existing block list.");
@@ -945,7 +945,7 @@ Status CommitBlockList(std::shared_ptr<Storage::Blobs::BlockBlobClient> block_bl
     // previously committed blocks.
     // https://learn.microsoft.com/en-us/rest/api/storageservices/put-block-list?tabs=microsoft-entra-id#request-body
     block_blob_client->CommitBlockList(block_ids, options);
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     return ExceptionToStatus(
         exception, "CommitBlockList failed for '", block_blob_client->GetUrl(),
         "'. Committing is required to flush an output/append stream.");
@@ -957,7 +957,7 @@ Status StageBlock(Blobs::BlockBlobClient* block_blob_client, const std::string&
                   Core::IO::MemoryBodyStream& content) {
   try {
     block_blob_client->StageBlock(id, content);
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     return ExceptionToStatus(
         exception, "StageBlock failed for '", block_blob_client->GetUrl(),
         "' new_block_id: '", id,
@@ -1023,7 +1023,7 @@ class ObjectAppendStream final : public io::OutputStream {
         }
         content_length_ = properties.Value.BlobSize;
         pos_ = content_length_;
-      } catch (const Storage::StorageException& exception) {
+      } catch (const Core::RequestFailedException& exception) {
         if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
           // No file exists but on flat namespace its possible there is a directory
           // marker or an implied directory. Ensure there is no directory before starting
@@ -1366,7 +1366,7 @@ Result<HNSSupport> CheckIfHierarchicalNamespaceIsEnabled(
     // Azurite issue detected.
     DCHECK(IsDfsEmulator(options));
     return HNSSupport::kDisabled;
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     // Flat namespace storage accounts with "soft delete" enabled return
     //
     //   "Conflict - This endpoint does not support BlobStorageEvents
@@ -1400,9 +1400,6 @@ Result<HNSSupport> CheckIfHierarchicalNamespaceIsEnabled(
                                  "Check for Hierarchical Namespace support on '",
                                  adlfs_client.GetUrl(), "' failed.");
     }
-  } catch (const Azure::Core::Http::TransportException& exception) {
-    return ExceptionToStatus(exception, "Check for Hierarchical Namespace support on '",
-                             adlfs_client.GetUrl(), "' failed.");
   } catch (const std::exception& exception) {
     return Status::UnknownError(
         "Check for Hierarchical Namespace support on '", adlfs_client.GetUrl(),
@@ -1436,7 +1433,7 @@ Result<FileInfo> GetContainerPropsAsFileInfo(const AzureLocation& location,
     info.set_type(FileType::Directory);
     info.set_mtime(std::chrono::system_clock::time_point{properties.Value.LastModified});
     return info;
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     if (IsContainerNotFound(exception)) {
       info.set_type(FileType::NotFound);
       return info;
@@ -1452,7 +1449,7 @@ Status CreateContainerIfNotExists(const std::string& container_name,
   try {
     container_client.CreateIfNotExists();
     return Status::OK();
-  } catch (const Storage::StorageException& exception) {
+  } catch (const Core::RequestFailedException& exception) {
     return ExceptionToStatus(exception, "Failed to create a container: ", container_name,
                              ": ", container_client.GetUrl());
   }
@@ -1545,7 +1542,7 @@ class LeaseGuard {
     DCHECK(release_attempt_pending_);
     try {
       lease_client_->Release();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(exception, "Failed to release the ",
                                lease_client_->GetLeaseId(), " lease");
     }
@@ -1588,7 +1585,7 @@ class LeaseGuard {
       break_or_expires_at_ =
           std::min(break_or_expires_at_,
                    SteadyClock::now() + break_period.ValueOr(std::chrono::seconds{0}));
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(exception, "Failed to break the ",
                                lease_client_->GetLeaseId(), " lease expiring in ",
                                remaining_time_ms().count(), "ms");
@@ -1783,7 +1780,7 @@ class AzureFileSystem::Impl {
       info.set_mtime(
           std::chrono::system_clock::time_point{properties.Value.LastModified});
       return info;
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         return FileInfo{location.all, FileType::NotFound};
       }
@@ -1858,7 +1855,7 @@ class AzureFileSystem::Impl {
       }
       info.set_type(FileType::NotFound);
       return info;
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (IsContainerNotFound(exception)) {
         return FileInfo{location.all, FileType::NotFound};
       }
@@ -1918,7 +1915,7 @@ class AzureFileSystem::Impl {
           RETURN_NOT_OK(on_container(container));
         }
       }
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(exception, "Failed to list account containers.");
     }
     return Status::OK();
@@ -1973,7 +1970,7 @@ class AzureFileSystem::Impl {
           }
         }
       }
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (IsContainerNotFound(exception) || exception.ErrorCode == "PathNotFound") {
         found = false;
       } else {
@@ -2086,7 +2083,7 @@ class AzureFileSystem::Impl {
           RETURN_NOT_OK(process_prefix(list_response.BlobPrefixes[blob_prefix_index]));
         }
       }
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (IsContainerNotFound(exception)) {
         found = false;
       } else {
@@ -2225,7 +2222,7 @@ class AzureFileSystem::Impl {
       if (container_info.type() == FileType::NotFound) {
         try {
           container_client.CreateIfNotExists();
-        } catch (const Storage::StorageException& exception) {
+        } catch (const Core::RequestFailedException& exception) {
           return ExceptionToStatus(exception, "Failed to create directory '",
                                    location.all, "': ", container_client.GetUrl());
         }
@@ -2252,7 +2249,7 @@ class AzureFileSystem::Impl {
         const auto& nonexistent_location = nonexistent_locations[i - 1];
         try {
           create_if_not_exists(container_client, nonexistent_location);
-        } catch (const Storage::StorageException& exception) {
+        } catch (const Core::RequestFailedException& exception) {
           return ExceptionToStatus(exception, "Failed to create directory '",
                                    location.all, "': ", container_client.GetUrl());
         }
@@ -2270,7 +2267,7 @@ class AzureFileSystem::Impl {
       try {
         create_if_not_exists(container_client, location);
         return Status::OK();
-      } catch (const Storage::StorageException& exception) {
+      } catch (const Core::RequestFailedException& exception) {
         if (IsContainerNotFound(exception)) {
           auto parent = location.parent();
           return PathNotFound(parent);
@@ -2378,7 +2375,7 @@ class AzureFileSystem::Impl {
     try {
       EnsureEmptyDirExistsImplThatThrows(container_client, location.path);
       return Status::OK();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(
           exception, operation_name, " failed to ensure empty directory marker '",
           location.path, "' exists in container: ", container_client.GetUrl());
@@ -2396,7 +2393,7 @@ class AzureFileSystem::Impl {
       // Only the "*IfExists" functions ever set Deleted to false.
       // All the others either succeed or throw an exception.
       DCHECK(response.Value.Deleted);
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (IsContainerNotFound(exception)) {
         return PathNotFound(location);
       }
@@ -2492,7 +2489,7 @@ class AzureFileSystem::Impl {
           if (!deferred_responses.empty()) {
             container_client.SubmitBatch(batch);
           }
-        } catch (const Storage::StorageException& exception) {
+        } catch (const Core::RequestFailedException& exception) {
           return ExceptionToStatus(exception, "Failed to delete blobs in a directory: ",
                                    location.path, ": ", container_client.GetUrl());
         }
@@ -2502,7 +2499,7 @@ class AzureFileSystem::Impl {
           try {
             auto delete_result = deferred_response.GetResponse();
             success = delete_result.Value.Deleted;
-          } catch (const Storage::StorageException& exception) {
+          } catch (const Core::RequestFailedException& exception) {
             success = false;
           }
           if (!success) {
@@ -2521,7 +2518,7 @@ class AzureFileSystem::Impl {
         }
       }
       return Status::OK();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       return ExceptionToStatus(exception,
                                "Failed to list blobs in a directory: ", location.path,
                                ": ", container_client.GetUrl());
@@ -2557,7 +2554,7 @@ class AzureFileSystem::Impl {
       // Only the "*IfExists" functions ever set Deleted to false.
       // All the others either succeed or throw an exception.
       DCHECK(response.Value.Deleted);
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.ErrorCode == "FilesystemNotFound" ||
           exception.ErrorCode == "PathNotFound") {
         if (require_dir_to_exist) {
@@ -2584,7 +2581,7 @@ class AzureFileSystem::Impl {
             auto sub_directory_client = adlfs_client.GetDirectoryClient(path.Name);
             try {
               sub_directory_client.DeleteRecursive();
-            } catch (const Storage::StorageException& exception) {
+            } catch (const Core::RequestFailedException& exception) {
               return ExceptionToStatus(
                   exception, "Failed to delete a sub directory: ", location.container,
                   kDelimiter, path.Name, ": ", sub_directory_client.GetUrl());
@@ -2596,7 +2593,7 @@ class AzureFileSystem::Impl {
             auto sub_file_client = adlfs_client.GetFileClient(path.Name);
             try {
               sub_file_client.Delete();
-            } catch (const Storage::StorageException& exception) {
+            } catch (const Core::RequestFailedException& exception) {
               return ExceptionToStatus(
                   exception, "Failed to delete a sub file: ", location.container,
                   kDelimiter, path.Name, ": ", sub_file_client.GetUrl());
@@ -2605,7 +2602,7 @@ class AzureFileSystem::Impl {
         }
       }
       return Status::OK();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (missing_dir_ok && exception.StatusCode == Http::HttpStatusCode::NotFound) {
         return Status::OK();
       }
@@ -2634,7 +2631,7 @@ class AzureFileSystem::Impl {
     try {
       [[maybe_unused]] auto result = lease_client->Acquire(lease_duration);
       DCHECK_EQ(result.Value.LeaseId, lease_client->GetLeaseId());
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (IsContainerNotFound(exception)) {
         if (allow_missing_container) {
           return nullptr;
@@ -2674,7 +2671,7 @@ class AzureFileSystem::Impl {
     try {
       [[maybe_unused]] auto result = lease_client->Acquire(lease_duration);
       DCHECK_EQ(result.Value.LeaseId, lease_client->GetLeaseId());
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         if (allow_missing) {
           return nullptr;
@@ -2749,7 +2746,7 @@ class AzureFileSystem::Impl {
       // Only the "*IfExists" functions ever set Deleted to false.
       // All the others either succeed or throw an exception.
       DCHECK(response.Value.Deleted);
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         // ErrorCode can be "FilesystemNotFound", "PathNotFound"...
         if (require_file_to_exist) {
@@ -2841,7 +2838,7 @@ class AzureFileSystem::Impl {
       // Only the "*IfExists" functions ever set Deleted to false.
       // All the others either succeed or throw an exception.
       DCHECK(response.Value.Deleted);
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         return check_if_location_exists_as_dir();
       }
@@ -2906,7 +2903,7 @@ class AzureFileSystem::Impl {
         if (!dest_is_empty) {
           return NotEmpty(dest);
         }
-      } catch (const Storage::StorageException& exception) {
+      } catch (const Core::RequestFailedException& exception) {
         return ExceptionToStatus(exception, "Failed to check that '", dest.container,
                                  "' is empty: ", dest_container_client.GetUrl());
       }
@@ -2936,6 +2933,10 @@ class AzureFileSystem::Impl {
         return ExceptionToStatus(exception, "Failed to rename container '", src.container,
                                  "' to '", dest.container,
                                  "': ", blob_service_client_->GetUrl());
+      } catch (const Core::RequestFailedException& exception) {
+        return ExceptionToStatus(exception, "Failed to rename container '", src.container,
+                                 "' to '", dest.container,
+                                 "': ", blob_service_client_->GetUrl());
       }
     } else if (dest_is_empty) {
       // Even if we deleted the empty dest.container, RenameBlobContainer() would still
@@ -2972,11 +2973,11 @@ class AzureFileSystem::Impl {
           src_lease_guard.BreakBeforeDeletion(kTimeNeededForContainerDeletion);
           src_container_client.Delete(options);
           src_lease_guard.Forget();
-        } catch (const Storage::StorageException& exception) {
+        } catch (const Core::RequestFailedException& exception) {
           return ExceptionToStatus(exception, "Failed to delete empty container: '",
                                    src.container, "': ", src_container_client.GetUrl());
         }
-      } catch (const Storage::StorageException& exception) {
+      } catch (const Core::RequestFailedException& exception) {
         return ExceptionToStatus(exception, "Unable to replace empty container: '",
                                  dest.all, "': ", dest_container_client.GetUrl());
       }
@@ -3117,7 +3118,7 @@ class AzureFileSystem::Impl {
       src_lease_guard.BreakBeforeDeletion(kTimeNeededForFileOrDirectoryRename);
       src_adlfs_client.RenameFile(src_path, dest_path, options);
       src_lease_guard.Forget();
-    } catch (const Storage::StorageException& exception) {
+    } catch (const Core::RequestFailedException& exception) {
       // https://learn.microsoft.com/en-gb/rest/api/storageservices/datalakestoragegen2/path/create
       if (exception.StatusCode == Http::HttpStatusCode::NotFound) {
         if (exception.ErrorCode == "PathNotFound") {
